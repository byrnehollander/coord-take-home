{"version":3,"sources":["AddressSearch.js","App.js","index.js"],"names":["VALID_CITIES","AddressSearch","setLatitude","setLongitude","setIsGeocoding","setError","clearResponse","useState","address","setAddress","isInNYC","setIsInNYC","handleCloseClick","value","onChange","onSelect","selected","i","length","includes","isAddressInNYC","geocodeByAddress","then","res","getLatLng","lat","lng","catch","error","highlightFirstSuggestion","getInputProps","suggestions","getSuggestionItemProps","placeholder","className","onClick","map","suggestion","formattedSuggestion","mainText","secondaryText","BASE_URL","params","URLSearchParams","radius_km","access_key","process","primary_use","vehicle_type","App","latitude","longitude","response","setResponse","isFetching","setIsFetching","isGeocoding","useEffect","a","set","axios","get","toString","fetchData","style","marginTop","fontWeight","validSpaces","data","features","filter","end","properties","metadata","distance_end_meters","start","distance_start_meters","renderNumParkingSpots","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.63d8f59c.chunk.js","sourcesContent":["import { useState } from 'react'\nimport PlacesAutocomplete, {\n  geocodeByAddress,\n  getLatLng\n} from 'react-places-autocomplete'\n\nconst VALID_CITIES = [\n  'New York, NY',\n  'Brooklyn, NY',\n  'Queens, NY',\n  'Staten Island, NY',\n  'Bronx, NY'\n]\n\nconst AddressSearch = ({\n  setLatitude,\n  setLongitude,\n  setIsGeocoding,\n  setError,\n  clearResponse\n}) => {\n  const [address, setAddress] = useState('')\n  const [isInNYC, setIsInNYC] = useState(false)\n\n  const isAddressInNYC = address => {\n    for (let i = 0; i < VALID_CITIES.length; i++) {\n      if (address.includes(VALID_CITIES[i])) {\n        return true\n      }\n    }\n    return false\n  }\n\n  const handleChange = address => {\n    setAddress(address)\n  }\n\n  const handleSelect = selected => {\n    setAddress(selected)\n    if (isAddressInNYC(selected)) {\n      setIsInNYC(true)\n      setIsGeocoding(true)\n      geocodeByAddress(selected)\n        .then(res => getLatLng(res[0]))\n        .then(({ lat, lng }) => {\n          setLatitude(lat)\n          setLongitude(lng)\n          setIsGeocoding(false)\n        })\n        .catch(error => {\n          setError(error)\n          setIsGeocoding(false)\n        })\n    } else if (isInNYC) {\n      setIsInNYC(false)\n    }\n  }\n\n  const handleCloseClick = () => {\n    setAddress('')\n    setIsInNYC(false)\n    setLatitude(null)\n    setLongitude(null)\n    clearResponse()\n  }\n\n  return (\n    <PlacesAutocomplete\n      value={address}\n      onChange={handleChange}\n      onSelect={handleSelect}\n      highlightFirstSuggestion\n    >\n      {({ getInputProps, suggestions, getSuggestionItemProps }) => {\n        return (\n          <div>\n            <div>\n              <input\n                {...getInputProps({\n                  placeholder: 'Search Places...',\n                  className: 'search-input'\n                })}\n              />\n              {address.length > 0 && (\n                <button\n                  className='clear-button'\n                  onClick={handleCloseClick}\n                >\n                  x\n                </button>\n              )}\n            </div>\n            {suggestions.length > 0 && (\n              <div>\n                {suggestions.map((suggestion, i) => {\n                  return (\n                    <div\n                      key={i}\n                      {...getSuggestionItemProps(suggestion, { })}\n                    >\n                      <strong>\n                        {suggestion.formattedSuggestion.mainText}\n                      </strong>{' '}\n                      <small>\n                        {suggestion.formattedSuggestion.secondaryText}\n                      </small>\n                    </div>\n                  )\n                })}\n              </div>\n            )}\n          </div>\n        )\n      }}\n    </PlacesAutocomplete>\n  )\n}\n\nexport default AddressSearch\n","import { useState, useEffect } from 'react'\nimport axios from 'axios'\nimport AddressSearch from './AddressSearch'\n\nconst MIN_PARKING_SPACE_LENGTH_METERS = 5.5\nconst RADIUS_KM = '0.3'\nconst PARKING_USE = 'park'\nconst ALL_VEHICLE_TYPES = 'all'\nconst ACCESS_KEY = process.env.REACT_APP_COORD_ACCESS_KEY\nconst BASE_URL = 'https://api.coord.co/v1/search/curbs/bylocation/time_rules?'\n\nconst initParams = {\n  radius_km: RADIUS_KM,\n  access_key: ACCESS_KEY,\n  primary_use: PARKING_USE,\n  vehicle_type: ALL_VEHICLE_TYPES\n}\n\nconst params = new URLSearchParams(initParams)\n\nconst App = () => {\n  const [latitude, setLatitude] = useState()\n  const [longitude, setLongitude] = useState()\n  const [response, setResponse] = useState()\n  const [error, setError] = useState()\n  const [isFetching, setIsFetching] = useState(false)\n  const [isGeocoding, setIsGeocoding] = useState(false)\n\n  useEffect(() => {\n    if (latitude && longitude) {\n      setIsFetching(true)\n      async function fetchData () {\n        try {\n          params.set('latitude', latitude)\n          params.set('longitude', longitude)\n          const response = await axios.get(BASE_URL + params.toString())\n          setResponse(response)\n        } catch (error) {\n          setError(error)\n        } finally {\n          setIsFetching(false)\n        }\n      }\n      fetchData()\n    }\n  }, [latitude, longitude])\n\n  const renderNumParkingSpots = () => {\n    if (isGeocoding || isFetching) {\n      return <div>Loading...</div>\n    }\n\n    if (!latitude || !longitude) {\n      return <div>Enter an NYC address above to get the number of parking spaces near you</div>\n    }\n\n    if (error) {\n      return <div>Error! {error}</div>\n    }\n\n    let validSpaces\n    if (response?.data?.features?.length > 0) {\n      validSpaces = response.data.features.filter(i => {\n        const end = i?.properties?.metadata?.distance_end_meters\n        const start = i?.properties?.metadata?.distance_start_meters\n        if (start && end) {\n          const length = end - start\n          return length >= MIN_PARKING_SPACE_LENGTH_METERS\n        }\n        return false\n      })\n    }\n    return <div>There are {validSpaces?.length || 0} parking spots nearby.</div>\n  }\n\n  return (\n    <div>\n      <div>Welcome! This app takes an address within one of the five boroughs of NYC and returns the number of available parking spots within 0.3 km (about 1000 feet).\n        <div style={{ marginTop: 20, fontWeight: 600 }}>Disclaimers:</div>\n        <ul>\n          <li>The parking spots returned are all at least 5.5m (18 feet) long. This means they'll fit cars like Toyota Camrys (16 feet long), but not large trucks.</li>\n          <li>Any type of car can park in these spots â€“ not just commercial vehicles.</li>\n          <li>The Google Geocoding/Places API costs $0.005/request so I've set a quota of 100 requests per day, which resets at midnight Pacific Time.</li>\n        </ul>\n      </div>\n      <AddressSearch\n        setLatitude={setLatitude}\n        setLongitude={setLongitude}\n        setIsGeocoding={setIsGeocoding}\n        setError={setError}\n        clearResponse={() => setResponse(null)}\n      />\n      {renderNumParkingSpots()}\n    </div>\n  )\n}\n\nexport default App\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n)\n"],"sourceRoot":""}